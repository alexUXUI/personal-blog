---
templateKey: blog-post
title: 'Performant Data Transformation with Transducers '
date: 2019-02-01T15:04:10.000Z
description: _
tags:
  - functional programming
  - tranduce
  - map
  - filter
  - reduce
  - javascript
---
In software development, a transducer is a performant functional programming technique for data processing and transformation. 

**What does it do?**

A transducer iterates over a collection of data and returns a new result.

Often times, in javascript, we accomplish this with `.map`, `.filter`, and `.reduce`.

```
[1,2,3]
  .map(timesTwo)
  .filter(isOdd)
  .reduce(sumEntries)
```

**Why do we need to do this differently?**

This approach is not as performant as it could be. A `.` chain series of functions, like the example above, works like this:

![alt text](https://cdn-images-1.medium.com/max/1600/1*mJicJiOZT4M9jwv6kMkwRg.gif)

The yellow arrows are functions, and the red lines are array items. Notice how each function needs to process all three items in the array before the next function is called?

This behavior _is_ the bottle-neck of the program. The problem with this approach is that each map, filter, and reduce function iterates over the collection and creates a new array of data. There are **4 arrays** in the gif above, generated by **3 iterations** of the collection. 

**How can we write a better solution?**

We can start by addressing the two main problems with the example program.

1) ↔️ Space complexity of **4 Arrays**: 

* there are two intermediary arrays in the gif above. The intermediary collections are not _necessary_ when we only need an input and an output array


2) ⏰ Time Complexity of **3 iterations**:

* The program iterates over the collection three times. Once with map, once with filter, and once with reduce

Let's improve this by:  

1) ↔️ Removing intermediary arrays
2) ⏰ Iterating over the data one time, instead of three

Just to re-cap: Our goal is to iterate over a collection one time, run multiple functions on each item in the collection, and return a new result - without using intermediary collections.

A transducer accomplishes our goal within the time and space constraints.

**How does a transducer work?**

A transducer iterates over a collection, runs multiple computations on each item (yellow arrows below), and returns a result. In addition, a transducer only iterates over a collection one time and does _not_ create intermediary collections.

![alt text](https://cdn-images-1.medium.com/max/800/1*rEOyWd0MTPv_NZvzDaFbkA.gif)

Notice how there are only two arrays in the gif above? 

No intermediary arrays solves our space complexity issue ↔️

See how each item goes through every function (yellow arrow) one by one, rather than the program to looping over the data three times?

One iteration (rather than three) reduces the time complexity of the algorithm by two thirds ⏰

## Transducer Implementation 

#### Transducers have 4 parts

1) Main function:
Contains all the computations your program will perform on each item in the collection of data 


2) Final function: _is_ the reducing function. It receives a new item once an item has been processed by the computations the Main function. The final function then takes the resulting item and adds it to the output of the transducer.


3) Seed data: Used to initialize the output of the transducer. It works just like the array in the following example: `.reduce((acc, val) => { return acc.concat(val) }, [])`


4) Input Data: any collection of data (that implements map).

#### Transducer Function

Each of the four transducer parts described above will be passed as arguments to the Transducer function:

`Transducer(Main, Final, Seed, Input)`

now that we know how to use and what each part of the transducer is, let's see what goes into each part, and 

#### Implementing each part

The Main Function:

the main function is a composition of the functions you want the transducer to run on each item in the collection.

Function composition is when the output of one function is the input of another. Composite functions can be described as `f(g(x))`, where the input of `f` is the output of `g(x)`.

Here's an example of function composition:
```
const composeTwo = (f, g) => (...x) => {
  return a(b(...x))
}
```


In the example above, `x` is each item in the collection of data.

We will demonstrate this and how the main function is implemented here:
```
const composeTwo = (f, g) => (...x) => {
  return a(b(...x))
}
```

```
const sumOne = x => x + 1
const timesTwo = x => x * 2

const mainFunction = composeTwo(
  sumOne,
  timesTwo
)

mainFunction(10)
```
 



